整体代码抄了老师给的优秀demo完成的，所以记录下自己的思考

###core
这部分主要是框架的核心，client和server走的netty+Http。包含了代理类生成，netty请求发送、响应处理。
RpcClientCglib是代理类的生成，利用了缓存，如果之前生成过会直接使用，如果没有会重新生成。
RpcInvocationHandler是请求发送与相应的具体实现，发送的请求会先序列化然后通过netty把请求发送到服务端
再将的到的结果反序列化对象。
core中还定义了编码和解码和netty的数据传输格式。

###api
这部分主要是接口和实体的定义。并没有具体地实现。

###server
这部分是对api的具体实现。将接口放入到了容器中，netty server启动后可以通过反射代理获取到接口
服务端收到请求后会先反序列化得到对象，处理好后再将结果序列化返回。整体的处理流程和客户端相反。

###client
客户端只需要使用RPC生成代理，即可完成方法的调用。这中间的代理类生成，请求发送和相应处理都有RPC框架
的客户端完成了。这样的RPC远程调用在客户端这部分看起来就像是调用了本地的方法一样。


RPC整体的开发流程：
- 1.定义接口：完成接口设计以及设计到的实体结构设计
- 2.客户端调用：客户端调用接口，获取结果，并反序列化成对象
- 3.服务端接收处理：服务端接收到请求，匹配相应的实现类，调用相应的方法，得到结果返回返回
